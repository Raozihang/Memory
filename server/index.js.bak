const http = require('http')
const fs = require('fs')
const path = require('path')
const { URL } = require('url')
const { spawnSync } = require('child_process')

// Optional dependencies
let sharp
try {
  sharp = require('sharp')
} catch (e) {
  console.warn('Sharp not found, image resizing will be disabled.')
}

// Configuration
const PORT = process.env.PORT || 8080
const ROOT_DIR = path.resolve(__dirname, '..')
const DATA_DIR = path.join(__dirname, 'data')
const STORAGE_DIR = path.join(__dirname, 'storage')

// Storage Module
let storage
try {
  storage = require('./storage')
} catch (e) {
  console.error('Failed to load storage module, falling back to local storage.', e)
  // Fallback implementation matching the original behavior
  const ensureDir = (p) => { if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true }) }
  ensureDir(STORAGE_DIR)
  ensureDir(path.join(STORAGE_DIR, 'originals'))
  ensureDir(path.join(STORAGE_DIR, 'derivatives'))
  
  storage = {
    type: 'local-fallback',
    saveOriginal(name, buffer) {
      const key = path.join('originals', name)
      fs.writeFileSync(path.join(STORAGE_DIR, key), buffer)
      return key
    },
    read(key) {
      return fs.readFileSync(path.join(STORAGE_DIR, key))
    },
    getSignedUrl(key) {
      return `/api/files/${encodeURIComponent(key)}`
    },
    filePath(key) {
      return path.join(STORAGE_DIR, key)
    }
  }
}

// Database Paths
const DB = {
  photos: path.join(DATA_DIR, 'photos.json'),
  albums: path.join(DATA_DIR, 'albums.json'),
  shares: path.join(DATA_DIR, 'shares.json'),
  exif: path.join(DATA_DIR, 'exif.json'),
  derivatives: path.join(DATA_DIR, 'derivatives.json'),
  albumPhotos: path.join(DATA_DIR, 'album_photos.json')
}

// --- Initialization ---

function init() {
  ensureDir(DATA_DIR)
  ensureDir(STORAGE_DIR)
  ensureDir(path.join(STORAGE_DIR, 'originals'))
  ensureDir(path.join(STORAGE_DIR, 'derivatives'))

  seedFile(DB.photos, [])
  seedFile(DB.albums, [{ id: 'demo', title: '高2024级研学活动', description: '示例相册', cover_photo_id: null }])
  seedFile(DB.shares, [])
  seedFile(DB.exif, [])
  seedFile(DB.derivatives, [])
  seedFile(DB.albumPhotos, [])
  
  processPendingUploads()
}

function processPendingUploads() {
  try {
    const tmpUploadPath = path.join(ROOT_DIR, 'tmp', 'upload.json')
    if (fs.existsSync(tmpUploadPath)) {
      console.log('Processing pending upload:', tmpUploadPath)
      const sample = JSON.parse(fs.readFileSync(tmpUploadPath).toString())
      const photos = readJson(DB.photos)
      
      // Only process if photos are empty (demo mode?) or simply process it. 
      // Original logic: if ((photos||[]).length === 0 && ...)
      // We will stick to original logic for safety.
      if ((photos || []).length === 0 && sample && sample.dataUrl && sample.filename) {
        const id = Date.now().toString(36)
        const b64 = sample.dataUrl.split(',').pop()
        const buf = Buffer.from(b64, 'base64')
        const originalKey = path.join('originals', `${id}-${sample.filename}`)
        
        storage.saveOriginal(`${id}-${sample.filename}`, buf)
        
        const photo = {
          id,
          album_id: sample.albumId || 'demo',
          filename: sample.filename,
          storage_key: originalKey,
          mime: 'image/png',
          bytes: buf.length,
          taken_at: sample.taken_at || new Date().toISOString(),
          created_at: new Date().toISOString()
        }
        
        photos.push(photo)
        writeJson(DB.photos, photos)
        
        const derivatives = readJson(DB.derivatives)
        const extMap = { 'image/jpeg': '.jpg', 'image/png': '.png', 'image/webp': '.webp' }
        const baseName = path.parse(sample.filename).name
        
        const saveVariant = (dataUrl, type) => {
          if (!dataUrl) return null
          const mime = (dataUrl.split(';')[0].split(':')[1] || 'image/png')
          const ext = extMap[mime] || '.png'
          const key = path.join('derivatives', `${id}-${type}-${baseName}${ext}`)
          
          const b64Variant = dataUrl.split(',').pop()
          const bufVariant = Buffer.from(b64Variant, 'base64')
          fs.writeFileSync(path.join(STORAGE_DIR, key), bufVariant)
          
          derivatives.push({ photo_id: id, type, storage_key: key })
          return key
        }
        
        saveVariant(sample.displayDataUrl || sample.dataUrl, 'display')
        saveVariant(sample.mediumDataUrl || sample.dataUrl, 'medium')
        saveVariant(sample.thumbDataUrl || sample.dataUrl, 'thumb')
        
        writeJson(DB.derivatives, derivatives)
        
        const exifs = readJson(DB.exif)
        exifs.push({ photo_id: id, exif_json: { taken_at: photo.taken_at } })
        writeJson(DB.exif, exifs)
      }
    }
  } catch (e) {
    console.error('Error processing pending uploads:', e)
  }
}

// --- Helper Functions ---

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true })
}

function seedFile(p, v) {
  if (!fs.existsSync(p)) fs.writeFileSync(p, JSON.stringify(v, null, 2))
}

function readJson(p) {
  try {
    return JSON.parse(fs.readFileSync(p).toString())
  } catch (e) {
    return []
  }
}

function writeJson(p, v) {
  fs.writeFileSync(p, JSON.stringify(v, null, 2))
}

function sendJson(res, obj, statusCode = 200) {
  res.statusCode = statusCode
  res.setHeader('Content-Type', 'application/json')
  res.setHeader('Access-Control-Allow-Origin', '*')
  res.end(JSON.stringify(obj))
}

function sendFile(p, mime, res) {
  if (!fs.existsSync(p)) {
    res.statusCode = 404
    return res.end('File not found')
  }
  
  res.setHeader('Content-Type', mime)
  res.setHeader('Access-Control-Allow-Origin', '*')
  
  const longCache = 'public, max-age=31536000'
  const noCache = 'no-cache'
  const useNoCache = mime.startsWith('text/html')
  
  res.setHeader('Cache-Control', useNoCache ? noCache : longCache)
  fs.createReadStream(p).pipe(res)
}

function parseBody(req) {
  return new Promise(resolve => {
    let data = ''
    req.on('data', chunk => { data += chunk })
    req.on('end', () => {
      try {
        resolve(JSON.parse(data || '{}'))
      } catch {
        resolve({})
      }
    })
  })
}

async function generateDerivatives(id, filename, originalPath, dataUrl, displayDataUrl, mediumDataUrl, thumbDataUrl) {
  const derivatives = readJson(DB.derivatives)
  const extMap = { 'image/jpeg': '.jpg', 'image/png': '.png', 'image/webp': '.webp' }
  const baseName = path.parse(filename).name
  
  const saveVariant = (dUrl, type) => {
    if (!dUrl) return null
    const mime = (dUrl.split(';')[0].split(':')[1] || 'image/jpeg')
    const ext = extMap[mime] || '.jpg'
    const key = path.join('derivatives', `${id}-${type}-${baseName}${ext}`)
    
    const b64 = dUrl.split(',').pop()
    const buf = Buffer.from(b64, 'base64')
    fs.writeFileSync(path.join(STORAGE_DIR, key), buf)
    
    derivatives.push({ photo_id: id, type, storage_key: key })
    return key
  }

  // 1. Try to save provided derivatives
  let keyDisplay = saveVariant(displayDataUrl, 'display')
  let keyMedium = saveVariant(mediumDataUrl, 'medium')
  let keyThumb = saveVariant(thumbDataUrl, 'thumb')

  // 2. Fallback if missing
  if (!keyDisplay && !sharp) {
    keyDisplay = saveVariant(dataUrl, 'display')
  }

  // 3. Generate with Sharp if available
  if (sharp) {
    const fullOriginalPath = path.join(STORAGE_DIR, originalPath)
    
    if (!keyDisplay) {
      const k = path.join('derivatives', `${id}-display-${baseName}.webp`)
      try {
        await sharp(fullOriginalPath).resize(1600, 1600, { fit: 'inside' }).webp({ quality: 80 }).toFile(path.join(STORAGE_DIR, k))
        derivatives.push({ photo_id: id, type: 'display', storage_key: k })
        keyDisplay = k
      } catch (e) { console.error('Sharp error (display):', e) }
    }
    
    if (!keyMedium) {
      const k = path.join('derivatives', `${id}-medium-${baseName}.webp`)
      try {
        await sharp(fullOriginalPath).resize(800, 800, { fit: 'inside' }).webp({ quality: 70 }).toFile(path.join(STORAGE_DIR, k))
        derivatives.push({ photo_id: id, type: 'medium', storage_key: k })
        keyMedium = k
      } catch (e) { console.error('Sharp error (medium):', e) }
    }
    
    if (!keyThumb) {
      const k = path.join('derivatives', `${id}-thumb-${baseName}.webp`)
      try {
        await sharp(fullOriginalPath).resize(320, 320, { fit: 'inside' }).webp({ quality: 60 }).toFile(path.join(STORAGE_DIR, k))
        derivatives.push({ photo_id: id, type: 'thumb', storage_key: k })
        keyThumb = k
      } catch (e) { console.error('Sharp error (thumb):', e) }
    }
  }
  
  writeJson(DB.derivatives, derivatives)
}

// --- Request Handlers ---

async function handleApiRequest(req, res, url) {
  // 1. Health Check
  if (req.method === 'GET' && url.pathname === '/api/health') {
    return sendJson(res, { ok: true })
  }

  // 2. Serve Files (Originals/Derivatives)
  if (req.method === 'GET' && url.pathname.startsWith('/api/files/')) {
    const key = decodeURIComponent(url.pathname.replace('/api/files/', ''))
    const file = path.join(STORAGE_DIR, key)
    
    if (!fs.existsSync(file)) {
      return sendJson(res, { error: 'not found' }, 404)
    }
    
    const ext = path.extname(file).toLowerCase()
    const mime = ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg'
               : ext === '.png' ? 'image/png'
               : ext === '.webp' ? 'image/webp'
               : 'application/octet-stream'
    return sendFile(file, mime, res)
  }

  // 3. List Photos
  if (req.method === 'GET' && url.pathname === '/api/photos') {
    const photos = readJson(DB.photos)
    const derivatives = readJson(DB.derivatives)
    
    const items = photos.map(p => {
      const dDisplay = derivatives.find(x => x.photo_id === p.id && x.type === 'display')
      const dThumb = derivatives.find(x => x.photo_id === p.id && x.type === 'thumb')
      const dMedium = derivatives.find(x => x.photo_id === p.id && x.type === 'medium')
      
      return {
        ...p,
        display_key: dDisplay?.storage_key || p.storage_key,
        thumb_key: dThumb?.storage_key || dDisplay?.storage_key || p.storage_key,
        medium_key: dMedium?.storage_key || dDisplay?.storage_key || p.storage_key
      }
    })
    return sendJson(res, { items })
  }

  // 4. Upload Photo
  if (req.method === 'POST' && url.pathname === '/api/photos') {
    const body = await parseBody(req)
    const { albumId, filename, dataUrl, displayDataUrl, mediumDataUrl, thumbDataUrl, taken_at, exif } = body
    
    if (!dataUrl || !filename) {
      return sendJson(res, { error: 'missing file' }, 400)
    }

    const id = Date.now().toString(36)
    
    // Save Original
    const b64 = dataUrl.split(',').pop()
    const buf = Buffer.from(b64, 'base64')
    const originalKey = path.join('originals', `${id}-${filename}`)
    storage.saveOriginal(`${id}-${filename}`, buf)

    // Update DB
    const photos = readJson(DB.photos)
    const photo = {
      id,
      album_id: albumId || 'demo',
      filename,
      storage_key: originalKey,
      mime: 'image/jpeg',
      bytes: buf.length,
      taken_at: taken_at || new Date().toISOString(),
      created_at: new Date().toISOString()
    }
    photos.push(photo)
    writeJson(DB.photos, photos)
    
    // Save EXIF
    const exifs = readJson(DB.exif)
    exifs.push({ photo_id: id, exif_json: exif || { taken_at: photo.taken_at } })
    writeJson(DB.exif, exifs)

    // Generate Derivatives
    await generateDerivatives(id, filename, originalKey, dataUrl, displayDataUrl, mediumDataUrl, thumbDataUrl)

    return sendJson(res, { id })
  }

  // 5. Timeline
  if (req.method === 'GET' && url.pathname === '/api/timeline') {
    const photos = readJson(DB.photos)
    const groups = {}
    for (const p of photos) {
      const d = new Date(p.taken_at)
      if (isNaN(d.getTime())) continue
      const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`
      groups[key] = (groups[key] || 0) + 1
    }
    return sendJson(res, { days: groups })
  }

  // 6. Albums (List/Create/Update)
  if (req.method === 'GET' && url.pathname === '/api/albums') {
    const albums = readJson(DB.albums)
    return sendJson(res, { items: albums })
  }

  if (req.method === 'POST' && url.pathname === '/api/albums') {
    const body = await parseBody(req)
    const { title, description } = body
    const albums = readJson(DB.albums)
    const id = Date.now().toString(36)
    albums.push({ id, title: title || '未命名', description: description || '', cover_photo_id: null })
    writeJson(DB.albums, albums)
    return sendJson(res, { id })
  }

  if (req.method === 'PUT' && url.pathname.match(/^\/api\/albums\/([a-z0-9]+)$/)) {
    const id = url.pathname.split('/')[3]
    const body = await parseBody(req)
    const albums = readJson(DB.albums)
    const idx = albums.findIndex(x => x.id === id)
    if (idx < 0) return sendJson(res, { error: 'not found' }, 404)
    
    albums[idx] = { ...albums[idx], ...body }
    writeJson(DB.albums, albums)
    return sendJson(res, albums[idx])
  }

  // 7. Album Photos (Add to album)
  if (req.method === 'POST' && url.pathname.match(/^\/api\/albums\/([a-z0-9]+)\/photos$/)) {
    const albumId = url.pathname.split('/')[3]
    const body = await parseBody(req)
    const { photo_id, ordering } = body
    const list = readJson(DB.albumPhotos)
    list.push({ album_id: albumId, photo_id, ordering: ordering || 0 })
    writeJson(DB.albumPhotos, list)
    return sendJson(res, { ok: true })
  }

  // 8. Exports
  if (req.method === 'GET' && url.pathname === '/api/photos/export') {
    const albumId = url.searchParams.get('albumId') || 'demo'
    const photos = readJson(DB.photos).filter(p => p.album_id === albumId)
    return sendJson(res, { 
      albumId, 
      files: photos.map(p => ({ filename: p.filename, url: `/api/photos/${p.id}/download` })) 
    })
  }

  if ((req.method === 'POST' || req.method === 'GET') && url.pathname.match(/^\/api\/albums\/([a-z0-9]+)\/export$/)) {
    const albumId = url.pathname.split('/')[3]
    const photos = readJson(DB.photos).filter(p => p.album_id === albumId)
    const exportDir = path.join(STORAGE_DIR, 'exports')
    ensureDir(exportDir)
    
    const zipName = `album-${albumId}-${Date.now()}.zip`
    const zipPath = path.join(exportDir, zipName)
    const tmpDir = path.join(STORAGE_DIR, 'tmp', `export-${albumId}-${Date.now()}`)
    ensureDir(tmpDir)
    
    for (const p of photos) {
      const src = path.join(STORAGE_DIR, p.storage_key)
      const dest = path.join(tmpDir, p.filename)
      if (fs.existsSync(src)) fs.copyFileSync(src, dest)
    }
    
    try {
      // Using PowerShell for zipping on Windows
      spawnSync('powershell', ['-NoProfile', '-Command', `Compress-Archive -Path '${tmpDir}/*' -DestinationPath '${zipPath}' -Force`])
    } catch (e) {
      console.error('Zip generation failed:', e)
    }
    
    return sendJson(res, { url: `/api/files/${encodeURIComponent(path.relative(STORAGE_DIR, zipPath))}` })
  }

  // 9. Downloads & Info
  if (req.method === 'GET' && url.pathname.match(/^\/api\/photos\/([a-z0-9]+)\/download$/)) {
    const id = url.pathname.split('/')[3]
    const photos = readJson(DB.photos)
    const p = photos.find(x => x.id === id)
    if (!p) return sendJson(res, { error: 'not found' }, 404)
    return sendFile(path.join(STORAGE_DIR, p.storage_key), 'application/octet-stream', res)
  }

  if (req.method === 'GET' && url.pathname.match(/^\/api\/photos\/([a-z0-9]+)\/downloadUrl$/)) {
    const id = url.pathname.split('/')[3]
    const photos = readJson(DB.photos)
    const p = photos.find(x => x.id === id)
    if (!p) return sendJson(res, { error: 'not found' }, 404)
    return sendJson(res, { url: storage.getSignedUrl(p.storage_key) })
  }

  if (req.method === 'GET' && url.pathname.match(/^\/api\/photos\/([a-z0-9]+)\/exif$/)) {
    const id = url.pathname.split('/')[3]
    const exifs = readJson(DB.exif)
    const e = exifs.find(x => x.photo_id === id)
    if (!e) return sendJson(res, { error: 'not found' }, 404)
    return sendJson(res, e)
  }

  // 10. Sharing
  if (req.method === 'POST' && url.pathname === '/api/shares') {
    const body = await parseBody(req)
    const { subject_type, subject_id, expires_at } = body
    const code = Math.random().toString(36).slice(2, 8)
    const shares = readJson(DB.shares)
    shares.push({ 
      id: Date.now().toString(36), 
      code, 
      subject_type, 
      subject_id, 
      expires_at: expires_at || null, 
      permissions: ['view'] 
    })
    writeJson(DB.shares, shares)
    return sendJson(res, { code, url: `/s/${code}` })
  }

  // Unknown API
  return sendJson(res, { error: 'unknown api' }, 404)
}

function serveStatic(req, res, url) {
  const dist = path.join(ROOT_DIR, 'frontend-react', 'dist')
  let staticPath = path.join(dist, url.pathname.replace(/^\//, ''))
  
  if (url.pathname === '/') staticPath = path.join(dist, 'index.html')

  if (fs.existsSync(staticPath) && fs.statSync(staticPath).isFile()) {
    const ext = path.extname(staticPath)
    const mime = ext === '.html' ? 'text/html'
      : ext === '.css' ? 'text/css'
      : ext === '.js' ? 'text/javascript'
      : ext === '.svg' ? 'image/svg+xml'
      : ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg'
      : ext === '.png' ? 'image/png'
      : ext === '.webp' ? 'image/webp'
      : 'application/octet-stream'
    return sendFile(staticPath, mime, res)
  }
  
  // SPA Fallback
  if (req.method === 'GET' && !url.pathname.startsWith('/api') && !url.pathname.includes('.')) {
     const indexHtml = path.join(dist, 'index.html')
     if (fs.existsSync(indexHtml)) return sendFile(indexHtml, 'text/html', res)
  }

  res.statusCode = 404
  res.end('Not Found')
}

function handleSharePage(req, res, url) {
  const code = url.pathname.split('/')[2]
  const shares = readJson(DB.shares)
  const s = shares.find(x => x.code === code)
  
  res.setHeader('Content-Type', 'text/html; charset=utf-8')
  
  if (!s) {
    res.statusCode = 404
    return res.end('分享不存在')
  }
  
  if (s.subject_type === 'album') {
    const albums = readJson(DB.albums)
    const a = albums.find(x => x.id === s.subject_id)
    return res.end(`<h1>分享相册：${a ? a.title : '未知'}</h1> <p>代码：${code}</p> <a href="/">返回</a>`)
  }
  
  return res.end(`<h1>分享：${s.subject_type}</h1> <p>代码：${code}</p> <a href="/">返回</a>`)
}

// --- Server Main Loop ---

init()

const server = http.createServer(async (req, res) => {
  try {
    const url = new URL(req.url, `http://${req.headers.host}`)
    
    // Handle API
    if (url.pathname.startsWith('/api/')) {
      return await handleApiRequest(req, res, url)
    }
    
    // Handle Shares
    if (url.pathname.startsWith('/s/')) {
      return handleSharePage(req, res, url)
    }
    
    // Handle Static
    return serveStatic(req, res, url)
    
  } catch (err) {
    console.error('Server Error:', err)
    res.statusCode = 500
    res.end('Internal Server Error')
  }
})

server.listen(PORT, () => {
  console.log(`Album server running at http://localhost:${PORT}`)
  console.log(`Serving static files from: ${path.join(ROOT_DIR, 'frontend-react', 'dist')}`)
})
